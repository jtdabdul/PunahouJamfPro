#!/bin/bash
##Jamf Script General
#Display NameDisplay name for the script
#  Remove Files or Directories with args
#CategoryCategory to add the script to
#  Uninstallers
#InformationInformation to display to the administrator when the script is run
#NotesNotes to display about the script (e.g., who created it and when it was created)
#Created 2020/08/25 by JA
#pass in full paths for files or directories to remove from client
#2023/10/20 added comments to explain the loop to run function on each argument, enumerate the use of $1, $2, $3 in jamf scripts
#2025/11/20 JA add error catching for "Directory not empty" on rm -rf, attempt to use find to delete all files in the directory first and then remove directory
#############
pathToScript=$0
pathToPackage=$1
targetLocation=$2
targetVolume=$3

#enumerate args
#for((i=1;i<=$#;i++)); do
#	echo "${!i}"
#done
echo "entering Remove Files with Arguments"

if [ ! $# > 4 ]; then {
	echo "No arguments found.  Arguments expected"
	exit 1
} else {
	echo "At least one argument found."
}
fi

function removeFileOrDirectory () {
    local arg1=$1

    # Test to see if arg1 exists
    if [[ -e $arg1 ]]; then
        echo "$arg1 exists"

        # Test to see if $arg1 is a file
        if [[ -f $arg1 ]]; then
            echo "$arg1 is a file"
            echo "Removing file: rm $arg1"
            rm "$arg1" || echo "Error: rm failed on file $arg1"

        # Test to see if $arg1 is a directory
        elif [[ -d $arg1 ]]; then
            removeDirectory "$arg1"
		else
            echo "$arg1 exists but is neither a file nor a directory (e.g., a symbolic link or socket)."
        fi

    else
        echo "$arg1 does not exist"
    fi
}
function removeDirectory() {
	local arg1=$1
	local rm_output="" # Variable to store the output of rm -rf
	local find_strategy="find"
	
	#echo "In removeDirectory target $arg1"
	if [[ -d $arg1 ]]; then
		echo "$arg1 is a directory"
		echo "Attempt 1: rm -rf $arg1"

		# Execute rm -rf, capture output (stdout and stderr) into rm_output,
		# and prevent it from printing to the console immediately.
		# The || true ensures the script continues even if rm fails,
		# so we can inspect the output.
		rm_output=$(rm -rf "$arg1" 2>&1)
		if [ $? -ne 0 ]; then	#if rm -rf exit status is not 0 (success)
		    
			# Check for the specific "Directory not empty" error in the captured output
			if echo "$rm_output" | grep -q "Directory not empty"; then
				echo "---"
				echo "rm -rf failed with 'Directory not empty' error."
				echo "Employing Secondary Strategy: $find_strategy"

				# Secondary Strategy: Use find -depth and then rmdir
				find "$arg1" -depth -name '*' -exec rm -rf {} +

				# Try to remove the now-empty parent directory
				if rmdir "$arg1"; then
					echo "Secondary strategy successful: Directory removed."
				else
					echo "---"
					echo "Error: Secondary strategy failed. Directory or remaining contents may be protected (e.g., active mount, special permissions)."
					echo "Original rm output was: $rm_output"
					echo "---"
				fi
			else
		  		# Report a different rm -rf error
		    	echo "Error: rm -rf failed on $arg1 for an unknown reason."
		    	echo "Original rm output was: $rm_output"
		    fi
		fi
	else
		echo "$arg1 is not a directory"
	fi
}


#while arg-1 is non-empty, keep looping
#i starts at 4 because the first three args are predefined by jamf
#$1 = Mount point of the target drive. This is / if you're booted to the target or /Volumes/targetDrive if you're not booted to it.
#$2 = the computer name
#$3 = the current user's shortname
for((i=4;i<=$#;i++)); do
	if [[ ! -z "${!i}" ]]; then
		echo "${!i}"
		removeFileOrDirectory "${!i}"
	fi
done
exit 0
